////////////////////////////////////////////////////////////////////////////////////  LINNAEUS UNIVERSITY//  Copyright 2012 Linnaeus university, Media Technology, sweden.//  Some Rights Reserved.////  NOTICE: LNU Media Technology permits you to use and modify this file//  in accordance with the terms of the license agreement accompanying it.//////////////////////////////////////////////////////////////////////////////////package se.lnu.mediatechnology.stickossdk.core{	//--------------------------------------------------------------------------	//	// Imports	//	//--------------------------------------------------------------------------		// IMPORT FROM STICKOS SDK		import se.lnu.mediatechnology.stickossdk.application.State;	import se.lnu.mediatechnology.stickossdk.core.Session;	import se.lnu.mediatechnology.stickossdk.debug.FPSTicker;	import se.lnu.mediatechnology.stickossdk.debug.OBJTicker;	import se.lnu.mediatechnology.stickossdk.debug.RAMTicker;		// IMPORT FROM FLASH IDE		import flash.display.Sprite;	import flash.display.StageDisplayState;	import flash.display.StageQuality;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.geom.Rectangle;	import flash.ui.Mouse;	import flash.utils.getTimer;
		//--------------------------------------------------------------------------	//	// Abstract class	//	//--------------------------------------------------------------------------		/**	 * 	 *	Engine is the core of all games and applications created with mains SDK 	 *	and contains the game / application's most significant features such as 	 *	the main loop (update) and keyboard handling. Much of this functionality 	 *	is made available through the <code>Session</code> class.	 * 	 *	@author	Henrik Andersen	 *	@version 1.0	 * 	 */	public class Engine extends Sprite	{		//-----------------------------------------------------------------------		//		// Public properties		//		//-----------------------------------------------------------------------				public var timeElapsedBetweenFrames:Number;		public var timeRunningTotal:Number;				//-----------------------------------------------------------------------		//		// Protected properties		//		//-----------------------------------------------------------------------				protected var fpsCounter:FPSTicker;		protected var ramCounter:RAMTicker;		protected var objCounter:OBJTicker;				//-----------------------------------------------------------------------		//		// Private properties		//		//-----------------------------------------------------------------------				private var bootState:Class;		private var _state:State;		private var _fullScreen:Boolean;		private var _debugger:Boolean;				//-----------------------------------------------------------------------		//		// Private properties		//		//-----------------------------------------------------------------------				private const KEY_FULLSCREEN:String = 'ESCAPE';		private const KEY_DEBUGGER:String	= 'P';				//-----------------------------------------------------------------------		//		// Constructor method		//		//-----------------------------------------------------------------------				/**		 * 		 * Instantiate a new game.		 * 		 */		public function Engine(state:Class)		{			bootState = state;						addEventListener(Event.ADDED_TO_STAGE,		init);			addEventListener(Event.REMOVED_FROM_STAGE,	dealloc);		}				//--------------------------------------------------------------------------		//		// Public setter methods		//		//--------------------------------------------------------------------------				/**		 *		 *	The frame rate of the main stage ie the application frame rate.		 *		 *	@param	FrameRate	The desired application frame rate.		 * 		 */		public function set frameRate(FrameRate:Number):void 		{			stage.frameRate = FrameRate;		}				/**		 *		 *	The current application state, for example Main, Menu, Game, etc.		 *		 */		public function set state(NewState:State):void 		{			swapState(NewState);		}				/**		 *		 *	The current state of the full screen mode.		 *		 */		public function set fullScreen(FullScreen:Boolean):void 		{			if( _fullScreen != FullScreen){				_fullScreen  = FullScreen;			}			else			{				return;			}						if(_fullScreen)			{				var screenRectangle:Rectangle	= new Rectangle(0, 0, stage.stageWidth, stage.stageHeight);								stage.fullScreenSourceRect		= screenRectangle; 				stage.displayState				= StageDisplayState.FULL_SCREEN_INTERACTIVE;				stage.quality					= StageQuality.HIGH;				stage.focus						= stage;								Mouse.hide();			}			else			{				stage.displayState	= StageDisplayState.NORMAL;				stage.quality		= StageQuality.BEST;				stage.focus			= stage;								Mouse.show();			}		}				/**		 *		 *	Determines whether the debugging tools will be active or inactive.		 *		 */		public function set debugger(active:Boolean):void 		{			if(active == _debugger) return;						_debugger = active;						if(_debugger)			{				initDebugger();			}			else			{				deallocDebugger();			}		}				//--------------------------------------------------------------------------		//		// Public getter methods		//		//--------------------------------------------------------------------------				/**		 *		 *	The current state of the full screen mode.		 * 		 */		public function get frameRate():Number 		{			return stage.frameRate;		}				/**		 *		 *	The current application state, for example Main, Menu, Game, etc.		 *		 */		public function get state():State 		{			return _state;		}				/**		 *		 *	The current state of the full screen mode.		 *		 */		public function get fullScreen():Boolean 		{			return _fullScreen;		}				/**		 *		 *	Determines whether the debugging tools will be active or inactive.		 *		 */		public function get debugger():Boolean 		{			return _debugger;		}				//-----------------------------------------------------------------------		//		// Private methods		//		//-----------------------------------------------------------------------				/**		 *		 *	Begins the instantiation of the fundamental methods for this class.		 *	All functionality which should be initiated at the beginning of the 		 *	class should be called through this method.		 * 		 *	@param		event		Enter frame event (Default: null).		 *		 */		private function init(event:Event = null):void		{			initSession();			initState();			initScreen();			initGlobalEvents();		}				/**		 *		 *	Initiates the static class <code>Session</code> by calling the 		 *	<code>Session</code> init method. The method expects a parameter in 		 *	the form of an instance of the current application(Engine).		 *		 */		private function initSession():void		{			Session.init(this);		}				/**		 *		 *	Prepares possible display settings. Default is just full screen mode.		 *		 */		private function initScreen():void		{			fullScreen = true;		}				/**		 *		 *	Initiates the first application state, the same as submitted in the 		 *	class constructor.		 *		 */		private function initState():void		{			state = new bootState();		}				/**		 *		 *	initiates basic event handlers.		 *		 */		private function initGlobalEvents():void		{			initKeyboardEvents();			initUpdateEvent();		}					/**		 *		 *	initiates basic keyboard handling.		 *		 */		private function initKeyboardEvents():void 		{			stage.addEventListener(KeyboardEvent.KEY_DOWN,	Session.keyboard.handleKeyDown);			stage.addEventListener(KeyboardEvent.KEY_UP,	Session.keyboard.handleKeyUp);		}				/**		 *		 *	initiates basic debugging tools such as FPS and RAM counter.		 *		 */		protected function initDebugger():void		{						fpsCounter = new FPSTicker();			ramCounter = new RAMTicker(90);			objCounter = new OBJTicker(170);						stage.addChild(fpsCounter);			stage.addChild(ramCounter);			stage.addChild(objCounter);		}				/**		 *		 *	Initializes the basic application loop, if it stops it will stop the 		 *	entire application. The purpose is to handle all updates through this 		 *	loop, good a the pause system etc.		 *		 */		private function initUpdateEvent():void 		{			addEventListener(Event.ENTER_FRAME, update);		}				/**		 *		 *	The fundamental update function, updates all application objects.		 * 		 *	@param	event	Enter frame event.		 *		 */		private function update(event:Event):void 		{			updateTime();						Session.update();			state.update();						updateGlobalControls();			updateDebugger();		}				/**		 * 		 *	A global update function for the keyboard. This function checks if the 		 *	full screen mode should be enabled or disabled.		 *		 */		private function updateGlobalControls():void 		{			if(Session.keyboard.pressedOnce(this.KEY_FULLSCREEN)){				fullScreen = !fullScreen;			}						if(Session.keyboard.pressedOnce(this.KEY_DEBUGGER)){				debugger = !debugger;			}		}				/**		 * 		 * 	Updates the debugging tools.		 * 		 */		private function updateDebugger():void		{			if(!debugger) return;						fpsCounter.update();			ramCounter.update();			objCounter.update();		}				/**		 * 		 * 	This private method used to calculate the time between frames. 		 *	The method also keeps track of how long the application has been 		 * 	active.		 * 		 *	@return void		 * 		 */		private function updateTime():void		{			var now:uint				= getTimer();			var delta:uint				= (now - timeRunningTotal);			timeElapsedBetweenFrames 	= (delta / 1000);			timeRunningTotal			= now;		}				/**		 *		 *	This is the class dealloc function, it activates the shutdown process 		 *	when the application has been removed from the scene.		 * 		 *	@param	event	Enter frame event.		 * 		 *	@return void		 * 		 */		private function dealloc(event:Event):void 		{			removeEventListener(Event.ENTER_FRAME,				update);			stage.removeEventListener(KeyboardEvent.KEY_DOWN,	Session.keyboard.handleKeyDown);			stage.removeEventListener(KeyboardEvent.KEY_UP,		Session.keyboard.handleKeyUp);						deallocDebugger();						if(_state) _state.dealloc();		}				/**		 * 		 * 	DESC..		 * 		 *	TODO:	Hanteringen av debuggern är inte särskillt säker, ska inte behöva kolla 		 * 			om värdena existerar.		 * 		 */		private function deallocDebugger():void		{			if(fpsCounter)			stage.removeChild(fpsCounter);						if(ramCounter)			stage.removeChild(ramCounter);						if(objCounter)			stage.removeChild(objCounter);						fpsCounter = null;			ramCounter = null;			objCounter = null;		}				/**		 *		 *	Shifts between application states. Turns off, cleans up after and 		 *	activates application states.		 * 		 *	@param	NewState	The new application State.		 *		 */		private function swapState(NewState:State):void 		{			Session.pauseTimer.clear();						if(_state)			{								while(numChildren > 0){					removeChild(getChildAt(0));				}								_state.dealloc();			}						_state = null;			_state = NewState;			_state.init();						stage.focus = stage;		}	}}